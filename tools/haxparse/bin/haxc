#!/usr/bin/env perl
use v5.36;
use strict;
use warnings;

use FindBin qw($Bin);
use lib "$Bin/../lib";

use Getopt::Long qw(GetOptionsFromArray);
use File::Basename qw(dirname);
use File::Spec;

use Hax::Lexer;
use Hax::Parser;
use Hax::Check::Imports;
use Hax::Check::ImportCollision;
use Hax::Check::ResolveImports;
use Hax::Check::BoolOps;
use Hax::Check::CaseExhaustive;
use Hax::Check::CasePayloads;
use Hax::Check::CaseBinderScope;
use Hax::Check::RefParamRebind;
use Hax::Check::ExprTypes;
use Hax::Check::Unreachable;
use Hax::Check::MustReturn;
use Hax::Check::Entrypoint;

sub usage ($msg = undef) {
  print "$msg\n" if defined $msg;
  print <<"USAGE";
usage:
  haxc check [options] <file.hax|dir>

options:
  -I <dir>     Add an import root (may be repeated)
  --std <dir>  Set standard library root (default: std)

notes:
  * The directory containing the root file is always searched first for imports.
  * Module path mapping: A::B::C -> A/B/C.hax
USAGE
  exit(defined $msg ? 2 : 0);
}

sub slurp_utf8 ($path) {
  open(my $fh, '<:encoding(UTF-8)', $path) or die "open $path: $!\n";
  return do { local $/; <$fh> };
}

sub _die_first_err (@errs) {
  return if !@errs;
  my $e = $errs[0];
  die "$e->{msg} at $e->{file}:$e->{line}:$e->{col}\n";
}

sub parse_and_check_program ($path, %opts) {
  my $std_root = $opts{std_root} // 'std';
  my $include  = $opts{include}  // [];

  my $src = slurp_utf8($path);

  my $lex = Hax::Lexer->new(file => $path, src => $src);
  my $p   = Hax::Parser->new(lexer => $lex);
  my $ast = $p->parse_program;  # dies on syntax error

  _die_first_err(Hax::Check::Imports::check_module($ast));
  _die_first_err(Hax::Check::ImportCollision::check_module($ast));

  _die_first_err(Hax::Check::ResolveImports::check_module($ast, std_root => $std_root, include => $include));
  _die_first_err(Hax::Check::CaseExhaustive::check_module($ast, std_root => $std_root, include => $include));
  _die_first_err(Hax::Check::CasePayloads::check_module($ast, std_root => $std_root, include => $include));

  _die_first_err(Hax::Check::CaseBinderScope::check_module($ast));
  _die_first_err(Hax::Check::BoolOps::check_module($ast));
  _die_first_err(Hax::Check::RefParamRebind::check_module($ast));
  _die_first_err(Hax::Check::ExprTypes::check_module($ast));
  _die_first_err(Hax::Check::Unreachable::check_module($ast));
  _die_first_err(Hax::Check::MustReturn::check_module($ast));

  _die_first_err(Hax::Check::Entrypoint::check_program($ast));
  return 1;
}

sub cmd_check (@args) {
  my @I;
  my $std_root = 'std';

  my $ok = GetOptionsFromArray(
    \@args,
    'I=s@'   => \@I,
    'std=s'  => \$std_root,
    'h|help' => sub { usage() },
  );

  usage("invalid options") if !$ok;

  my $arg = shift(@args) // usage("missing <file.hax|dir>");

  my @files;
  if (-f $arg) {
    @files = ($arg);
  } elsif (-d $arg) {
    opendir(my $dh, $arg) or die "opendir $arg: $!\n";
    @files = sort map { File::Spec->catfile($arg, $_) }
             grep { /\.hax\z/ && -f File::Spec->catfile($arg, $_) } readdir($dh);
    closedir($dh);
    die "No .hax files found in $arg\n" if !@files;
  } else {
    die "No such file or directory: $arg\n";
  }

  my ($okc, $bad) = (0, 0);
  for my $path (@files) {
    my $root_dir = dirname($path);
    my @include = ($root_dir, @I);

    eval { parse_and_check_program($path, std_root => $std_root, include => \@include); 1 } or do {
      chomp(my $err = $@ || 'error');
      print "NOT OK  $path\n$err\n";
      $bad++;
      next;
    };

    print "OK      $path\n";
    $okc++;
  }

  print "\nSummary: OK=$okc  FAIL=$bad\n";
  exit($bad ? 1 : 0);
}

my $cmd = shift(@ARGV) // usage();

if ($cmd eq 'check') {
  cmd_check(@ARGV);
}

usage("unknown command: $cmd");
